/* http-client.c generated by valac, the Vala compiler
 * generated from http-client.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: t; c-basic-offset: 2; tab-width: 2 -*- */
/*
 * http-client.vala
 * Copyright (C) Pontus Ã–stlund 2009 <pontus@poppa.se>
 *
 * This file is part of Roxen Application Launcher (RAL)
 * 
 * RAL is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * RAL is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with RAL.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <libsoup/soup.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gio/gio.h>


#define ROXENLAUNCHER_HTTP_TYPE_REQUEST (roxenlauncher_http_request_get_type ())
#define ROXENLAUNCHER_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ROXENLAUNCHER_HTTP_TYPE_REQUEST, RoxenlauncherHTTPRequest))
#define ROXENLAUNCHER_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ROXENLAUNCHER_HTTP_TYPE_REQUEST, RoxenlauncherHTTPRequestClass))
#define ROXENLAUNCHER_HTTP_IS_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ROXENLAUNCHER_HTTP_TYPE_REQUEST))
#define ROXENLAUNCHER_HTTP_IS_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ROXENLAUNCHER_HTTP_TYPE_REQUEST))
#define ROXENLAUNCHER_HTTP_REQUEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ROXENLAUNCHER_HTTP_TYPE_REQUEST, RoxenlauncherHTTPRequestClass))

typedef struct _RoxenlauncherHTTPRequest RoxenlauncherHTTPRequest;
typedef struct _RoxenlauncherHTTPRequestClass RoxenlauncherHTTPRequestClass;
typedef struct _RoxenlauncherHTTPRequestPrivate RoxenlauncherHTTPRequestPrivate;
#define _soup_uri_free0(var) ((var == NULL) ? NULL : (var = (soup_uri_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define ROXENLAUNCHER_HTTP_TYPE_RESPONSE (roxenlauncher_http_response_get_type ())
#define ROXENLAUNCHER_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ROXENLAUNCHER_HTTP_TYPE_RESPONSE, RoxenlauncherHTTPResponse))
#define ROXENLAUNCHER_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ROXENLAUNCHER_HTTP_TYPE_RESPONSE, RoxenlauncherHTTPResponseClass))
#define ROXENLAUNCHER_HTTP_IS_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ROXENLAUNCHER_HTTP_TYPE_RESPONSE))
#define ROXENLAUNCHER_HTTP_IS_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ROXENLAUNCHER_HTTP_TYPE_RESPONSE))
#define ROXENLAUNCHER_HTTP_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ROXENLAUNCHER_HTTP_TYPE_RESPONSE, RoxenlauncherHTTPResponseClass))

typedef struct _RoxenlauncherHTTPResponse RoxenlauncherHTTPResponse;
typedef struct _RoxenlauncherHTTPResponseClass RoxenlauncherHTTPResponseClass;
typedef struct _RoxenlauncherHTTPResponsePrivate RoxenlauncherHTTPResponsePrivate;

#define ROXENLAUNCHER_HTTP_RESPONSE_TYPE_HTTP_HEADER_FIELD (roxenlauncher_http_response_http_header_field_get_type ())
typedef struct _RoxenlauncherHTTPResponseHttpHeaderField RoxenlauncherHTTPResponseHttpHeaderField;
#define _g_match_info_free0(var) ((var == NULL) ? NULL : (var = (g_match_info_free (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

struct _RoxenlauncherHTTPRequest {
	GObject parent_instance;
	RoxenlauncherHTTPRequestPrivate * priv;
};

struct _RoxenlauncherHTTPRequestClass {
	GObjectClass parent_class;
};

struct _RoxenlauncherHTTPRequestPrivate {
	SoupURI* my_uri;
	GeeHashMap* _headers;
	char* _http_version;
	gboolean _keep_alive;
};

struct _RoxenlauncherHTTPResponse {
	GObject parent_instance;
	RoxenlauncherHTTPResponsePrivate * priv;
};

struct _RoxenlauncherHTTPResponseClass {
	GObjectClass parent_class;
};

struct _RoxenlauncherHTTPResponseHttpHeaderField {
	char* proto;
	char* version;
	gint code;
	char* message;
};

struct _RoxenlauncherHTTPResponsePrivate {
	GeeHashMap* my_headers;
	char* _data;
	RoxenlauncherHTTPResponseHttpHeaderField response_result;
	guint8* data_buffer;
	gint data_buffer_length1;
	gint data_buffer_size;
};


extern gboolean roxenlauncher_http_do_trace;
gboolean roxenlauncher_http_do_trace = FALSE;
static gpointer roxenlauncher_http_request_parent_class = NULL;
static gpointer roxenlauncher_http_response_parent_class = NULL;

#define ROXENLAUNCHER_HTTP_VERSION_1_0 "1.0"
#define ROXENLAUNCHER_HTTP_VERSION_1_1 "1.1"
GType roxenlauncher_http_request_get_type (void);
#define ROXENLAUNCHER_HTTP_REQUEST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ROXENLAUNCHER_HTTP_TYPE_REQUEST, RoxenlauncherHTTPRequestPrivate))
enum  {
	ROXENLAUNCHER_HTTP_REQUEST_DUMMY_PROPERTY,
	ROXENLAUNCHER_HTTP_REQUEST_URI,
	ROXENLAUNCHER_HTTP_REQUEST_HEADERS,
	ROXENLAUNCHER_HTTP_REQUEST_HTTP_VERSION,
	ROXENLAUNCHER_HTTP_REQUEST_KEEP_ALIVE,
	ROXENLAUNCHER_HTTP_REQUEST_TRACE
};
RoxenlauncherHTTPRequest* roxenlauncher_http_request_new (const char* the_uri);
RoxenlauncherHTTPRequest* roxenlauncher_http_request_construct (GType object_type, const char* the_uri);
RoxenlauncherHTTPRequest* roxenlauncher_http_request_new_from_uri (SoupURI* the_uri);
RoxenlauncherHTTPRequest* roxenlauncher_http_request_construct_from_uri (GType object_type, SoupURI* the_uri);
SoupURI* roxenlauncher_http_request_get_uri (RoxenlauncherHTTPRequest* self);
gboolean roxenlauncher_http_request_get_keep_alive (RoxenlauncherHTTPRequest* self);
const char* roxenlauncher_http_request_get_http_version (RoxenlauncherHTTPRequest* self);
static char* roxenlauncher_http_request_headers_to_string (RoxenlauncherHTTPRequest* self);
RoxenlauncherHTTPResponse* roxenlauncher_http_response_new (GInputStream* stream);
RoxenlauncherHTTPResponse* roxenlauncher_http_response_construct (GType object_type, GInputStream* stream);
GType roxenlauncher_http_response_get_type (void);
RoxenlauncherHTTPResponse* roxenlauncher_http_request_do_method (RoxenlauncherHTTPRequest* self, char* method, const char* data);
void roxenlauncher_http_request_set_uri (RoxenlauncherHTTPRequest* self, SoupURI* value);
GeeHashMap* roxenlauncher_http_request_get_headers (RoxenlauncherHTTPRequest* self);
void roxenlauncher_http_request_set_headers (RoxenlauncherHTTPRequest* self, GeeHashMap* value);
void roxenlauncher_http_request_set_http_version (RoxenlauncherHTTPRequest* self, const char* value);
void roxenlauncher_http_request_set_keep_alive (RoxenlauncherHTTPRequest* self, gboolean value);
gboolean roxenlauncher_http_request_get_trace (RoxenlauncherHTTPRequest* self);
void roxenlauncher_http_request_set_trace (RoxenlauncherHTTPRequest* self, gboolean value);
static void roxenlauncher_http_request_finalize (GObject* obj);
static void roxenlauncher_http_request_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void roxenlauncher_http_request_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType roxenlauncher_http_response_http_header_field_get_type (void);
RoxenlauncherHTTPResponseHttpHeaderField* roxenlauncher_http_response_http_header_field_dup (const RoxenlauncherHTTPResponseHttpHeaderField* self);
void roxenlauncher_http_response_http_header_field_free (RoxenlauncherHTTPResponseHttpHeaderField* self);
void roxenlauncher_http_response_http_header_field_copy (const RoxenlauncherHTTPResponseHttpHeaderField* self, RoxenlauncherHTTPResponseHttpHeaderField* dest);
void roxenlauncher_http_response_http_header_field_destroy (RoxenlauncherHTTPResponseHttpHeaderField* self);
#define ROXENLAUNCHER_HTTP_RESPONSE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ROXENLAUNCHER_HTTP_TYPE_RESPONSE, RoxenlauncherHTTPResponsePrivate))
enum  {
	ROXENLAUNCHER_HTTP_RESPONSE_DUMMY_PROPERTY,
	ROXENLAUNCHER_HTTP_RESPONSE_HEADERS,
	ROXENLAUNCHER_HTTP_RESPONSE_DATA,
	ROXENLAUNCHER_HTTP_RESPONSE_VERSION,
	ROXENLAUNCHER_HTTP_RESPONSE_STATUS_CODE,
	ROXENLAUNCHER_HTTP_RESPONSE_STATUS_TEXT
};
static guint8* _vala_array_dup1 (guint8* self, int length);
guint8* roxenlauncher_http_concat (guint8* all, int all_length1, guint8* tmp, int tmp_length1, int* result_length1);
static void roxenlauncher_http_response_make_defaults (RoxenlauncherHTTPResponse* self);
guint8* roxenlauncher_http_ltrim_uint8_array (guint8* array, int array_length1, glong offset, int* result_length1);
static void roxenlauncher_http_response_set_data (RoxenlauncherHTTPResponse* self, const char* value);
static void roxenlauncher_http_response_parse_headers (RoxenlauncherHTTPResponse* self, const char* header);
gboolean roxenlauncher_http_response_http_header_field_parse_line (RoxenlauncherHTTPResponseHttpHeaderField *self, const char* line);
glong roxenlauncher_http_strpos (const char* haystack, const char* needle);
GeeHashMap* roxenlauncher_http_response_get_headers (RoxenlauncherHTTPResponse* self);
const char* roxenlauncher_http_response_get_data (RoxenlauncherHTTPResponse* self);
guint8* roxenlauncher_http_response_get_raw_data (RoxenlauncherHTTPResponse* self, int* result_length1);
const char* roxenlauncher_http_response_get_version (RoxenlauncherHTTPResponse* self);
gint roxenlauncher_http_response_get_status_code (RoxenlauncherHTTPResponse* self);
const char* roxenlauncher_http_response_get_status_text (RoxenlauncherHTTPResponse* self);
static void roxenlauncher_http_response_finalize (GObject* obj);
static void roxenlauncher_http_response_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void roxenlauncher_http_response_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);



RoxenlauncherHTTPRequest* roxenlauncher_http_request_construct (GType object_type, const char* the_uri) {
	RoxenlauncherHTTPRequest * self;
	SoupURI* _tmp0_;
	g_return_val_if_fail (the_uri != NULL, NULL);
	self = (RoxenlauncherHTTPRequest*) g_object_new (object_type, NULL);
	self->priv->my_uri = (_tmp0_ = soup_uri_new (the_uri), _soup_uri_free0 (self->priv->my_uri), _tmp0_);
	return self;
}


RoxenlauncherHTTPRequest* roxenlauncher_http_request_new (const char* the_uri) {
	return roxenlauncher_http_request_construct (ROXENLAUNCHER_HTTP_TYPE_REQUEST, the_uri);
}


RoxenlauncherHTTPRequest* roxenlauncher_http_request_construct_from_uri (GType object_type, SoupURI* the_uri) {
	RoxenlauncherHTTPRequest * self;
	SoupURI* _tmp0_;
	g_return_val_if_fail (the_uri != NULL, NULL);
	self = (RoxenlauncherHTTPRequest*) g_object_new (object_type, NULL);
	self->priv->my_uri = (_tmp0_ = soup_uri_copy (the_uri), _soup_uri_free0 (self->priv->my_uri), _tmp0_);
	return self;
}


RoxenlauncherHTTPRequest* roxenlauncher_http_request_new_from_uri (SoupURI* the_uri) {
	return roxenlauncher_http_request_construct_from_uri (ROXENLAUNCHER_HTTP_TYPE_REQUEST, the_uri);
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, -1);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


RoxenlauncherHTTPResponse* roxenlauncher_http_request_do_method (RoxenlauncherHTTPRequest* self, char* method, const char* data) {
	RoxenlauncherHTTPResponse* result;
	GError * _inner_error_;
	char* _tmp0_;
	glong _tmp1_ = 0L;
	glong content_len;
	const char* _tmp2_;
	GQuark _tmp5_;
	const char* _tmp4_;
	static GQuark _tmp5__label0 = 0;
	char* req;
	char* _tmp8_;
	char* _tmp7_;
	char* _tmp6_;
	GResolver* resolver;
	GList* addresses;
	GInetAddress* address;
	GSocketClient* client;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (method != NULL, NULL);
	_inner_error_ = NULL;
	method = (_tmp0_ = g_utf8_strup (method, -1), _g_free0 (method), _tmp0_);
	if (data != NULL) {
		_tmp1_ = string_get_length (data);
	} else {
		_tmp1_ = (glong) 0;
	}
	content_len = _tmp1_;
	gee_abstract_map_set ((GeeAbstractMap*) self->priv->_headers, "Host", roxenlauncher_http_request_get_uri (self)->host);
	_tmp2_ = NULL;
	if (self->priv->_keep_alive) {
		_tmp2_ = "keep-alive";
	} else {
		_tmp2_ = "close";
	}
	gee_abstract_map_set ((GeeAbstractMap*) self->priv->_headers, "Connection", _tmp2_);
	if (content_len != 0) {
		char* _tmp3_;
		gee_abstract_map_set ((GeeAbstractMap*) self->priv->_headers, "Content-Length", _tmp3_ = g_strdup_printf ("%li", content_len));
		_g_free0 (_tmp3_);
	}
	_tmp4_ = method;
	_tmp5_ = (NULL == _tmp4_) ? 0 : g_quark_from_string (_tmp4_);
	if (_tmp5_ == ((0 != _tmp5__label0) ? _tmp5__label0 : (_tmp5__label0 = g_quark_from_static_string ("POST"))))
	do {
		if (!gee_map_contains ((GeeMap*) self->priv->_headers, "Content-Type")) {
			gee_abstract_map_set ((GeeAbstractMap*) self->priv->_headers, "Content-Type", "application/x-www-form-urlencoded");
		}
		break;
	} while (0); else
	do {
		if (!gee_map_contains ((GeeMap*) self->priv->_headers, "Content-Type")) {
			gee_abstract_map_set ((GeeAbstractMap*) self->priv->_headers, "Content-Type", "text/plain");
		}
		break;
	} while (0);
	req = g_strdup_printf ("%s %s HTTP/%s\r\n", method, roxenlauncher_http_request_get_uri (self)->path, self->priv->_http_version);
	req = (_tmp8_ = g_strconcat (req, _tmp7_ = g_strconcat (_tmp6_ = roxenlauncher_http_request_headers_to_string (self), "\r\n", NULL), NULL), _g_free0 (req), _tmp8_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp6_);
	if (data != NULL) {
		char* _tmp9_;
		req = (_tmp9_ = g_strconcat (req, data, NULL), _g_free0 (req), _tmp9_);
	}
	if (roxenlauncher_http_do_trace) {
		{
			char** _tmp10_;
			char** tmp_collection;
			int tmp_collection_length1;
			int tmp_it;
			tmp_collection = _tmp10_ = g_strsplit (req, "\r\n", 0);
			tmp_collection_length1 = _vala_array_length (_tmp10_);
			for (tmp_it = 0; tmp_it < _vala_array_length (_tmp10_); tmp_it = tmp_it + 1) {
				char* tmp;
				tmp = g_strdup (tmp_collection[tmp_it]);
				{
					fprintf (stderr, "> %s\n", tmp);
					_g_free0 (tmp);
				}
			}
			tmp_collection = (_vala_array_free (tmp_collection, tmp_collection_length1, (GDestroyNotify) g_free), NULL);
		}
	}
	resolver = _g_object_ref0 (g_resolver_get_default ());
	addresses = NULL;
	{
		GList* _tmp11_;
		_tmp11_ = g_resolver_lookup_by_name (resolver, roxenlauncher_http_request_get_uri (self)->host, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch8_g_error;
			goto __finally8;
		}
		addresses = _tmp11_;
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("http-client.vala:155: Unable to resolv address for %s!", roxenlauncher_http_request_get_uri (self)->host);
			result = NULL;
			_g_error_free0 (e);
			_g_free0 (req);
			_g_object_unref0 (resolver);
			_g_free0 (method);
			return result;
		}
	}
	__finally8:
	if (_inner_error_ != NULL) {
		_g_free0 (req);
		_g_object_unref0 (resolver);
		_g_free0 (method);
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	address = _g_object_ref0 ((GInetAddress*) g_list_nth_data (addresses, (guint) 0));
	client = g_socket_client_new ();
	{
		GInetSocketAddress* _tmp12_;
		GSocketConnection* _tmp13_;
		GSocketConnection* con;
		con = (_tmp13_ = _g_object_ref0 (g_socket_client_connect (client, (GSocketConnectable*) (_tmp12_ = (GInetSocketAddress*) g_inet_socket_address_new (address, (guint16) roxenlauncher_http_request_get_uri (self)->port)), NULL, &_inner_error_)), _g_object_unref0 (_tmp12_), _tmp13_);
		if (_inner_error_ != NULL) {
			goto __catch9_g_error;
			goto __finally9;
		}
		g_output_stream_write (g_io_stream_get_output_stream ((GIOStream*) con), req, strlen (req), NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (con);
			goto __catch9_g_error;
			goto __finally9;
		}
		result = roxenlauncher_http_response_new (g_io_stream_get_input_stream ((GIOStream*) con));
		_g_object_unref0 (con);
		_g_free0 (req);
		_g_object_unref0 (resolver);
		_g_object_unref0 (address);
		_g_object_unref0 (client);
		_g_free0 (method);
		return result;
	}
	goto __finally9;
	__catch9_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("http-client.vala:170: Unable to connect to host %s", roxenlauncher_http_request_get_uri (self)->host);
			_g_error_free0 (e);
		}
	}
	__finally9:
	if (_inner_error_ != NULL) {
		_g_free0 (req);
		_g_object_unref0 (resolver);
		_g_object_unref0 (address);
		_g_object_unref0 (client);
		_g_free0 (method);
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	_g_free0 (req);
	_g_object_unref0 (resolver);
	_g_object_unref0 (address);
	_g_object_unref0 (client);
	_g_free0 (method);
	return result;
}


static char* roxenlauncher_http_request_headers_to_string (RoxenlauncherHTTPRequest* self) {
	char* result;
	char* ret;
	g_return_val_if_fail (self != NULL, NULL);
	ret = g_strdup ("");
	{
		GeeIterator* _entry_it;
		_entry_it = gee_iterable_iterator ((GeeIterable*) self->priv->_headers);
		while (TRUE) {
			GeeMapEntry* entry;
			char* _tmp1_;
			char* _tmp0_;
			if (!gee_iterator_next (_entry_it)) {
				break;
			}
			entry = (GeeMapEntry*) gee_iterator_get (_entry_it);
			ret = (_tmp1_ = g_strconcat (ret, _tmp0_ = g_strdup_printf ("%s: %s\r\n", (const char*) gee_map_entry_get_key (entry), (const char*) gee_map_entry_get_value (entry)), NULL), _g_free0 (ret), _tmp1_);
			_g_free0 (_tmp0_);
			_g_object_unref0 (entry);
		}
		_g_object_unref0 (_entry_it);
	}
	result = ret;
	return result;
}


SoupURI* roxenlauncher_http_request_get_uri (RoxenlauncherHTTPRequest* self) {
	SoupURI* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->my_uri;
	return result;
}


void roxenlauncher_http_request_set_uri (RoxenlauncherHTTPRequest* self, SoupURI* value) {
	SoupURI* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->my_uri = (_tmp0_ = soup_uri_copy (value), _soup_uri_free0 (self->priv->my_uri), _tmp0_);
	g_object_notify ((GObject *) self, "uri");
}


GeeHashMap* roxenlauncher_http_request_get_headers (RoxenlauncherHTTPRequest* self) {
	GeeHashMap* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_headers;
	return result;
}


void roxenlauncher_http_request_set_headers (RoxenlauncherHTTPRequest* self, GeeHashMap* value) {
	GeeHashMap* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_headers = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_headers), _tmp0_);
	g_object_notify ((GObject *) self, "headers");
}


const char* roxenlauncher_http_request_get_http_version (RoxenlauncherHTTPRequest* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_http_version;
	return result;
}


void roxenlauncher_http_request_set_http_version (RoxenlauncherHTTPRequest* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_http_version = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_http_version), _tmp0_);
	g_object_notify ((GObject *) self, "http-version");
}


gboolean roxenlauncher_http_request_get_keep_alive (RoxenlauncherHTTPRequest* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_keep_alive;
	return result;
}


void roxenlauncher_http_request_set_keep_alive (RoxenlauncherHTTPRequest* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_keep_alive = value;
	g_object_notify ((GObject *) self, "keep-alive");
}


gboolean roxenlauncher_http_request_get_trace (RoxenlauncherHTTPRequest* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = roxenlauncher_http_do_trace;
	return result;
}


void roxenlauncher_http_request_set_trace (RoxenlauncherHTTPRequest* self, gboolean value) {
	g_return_if_fail (self != NULL);
	roxenlauncher_http_do_trace = value;
	g_object_notify ((GObject *) self, "trace");
}


static void roxenlauncher_http_request_class_init (RoxenlauncherHTTPRequestClass * klass) {
	roxenlauncher_http_request_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RoxenlauncherHTTPRequestPrivate));
	G_OBJECT_CLASS (klass)->get_property = roxenlauncher_http_request_get_property;
	G_OBJECT_CLASS (klass)->set_property = roxenlauncher_http_request_set_property;
	G_OBJECT_CLASS (klass)->finalize = roxenlauncher_http_request_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_HTTP_REQUEST_URI, g_param_spec_boxed ("uri", "uri", "uri", SOUP_TYPE_URI, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_HTTP_REQUEST_HEADERS, g_param_spec_object ("headers", "headers", "headers", GEE_TYPE_HASH_MAP, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_HTTP_REQUEST_HTTP_VERSION, g_param_spec_string ("http-version", "http-version", "http-version", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_HTTP_REQUEST_KEEP_ALIVE, g_param_spec_boolean ("keep-alive", "keep-alive", "keep-alive", TRUE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_HTTP_REQUEST_TRACE, g_param_spec_boolean ("trace", "trace", "trace", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void roxenlauncher_http_request_instance_init (RoxenlauncherHTTPRequest * self) {
	self->priv = ROXENLAUNCHER_HTTP_REQUEST_GET_PRIVATE (self);
	self->priv->_headers = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	self->priv->_http_version = g_strdup (ROXENLAUNCHER_HTTP_VERSION_1_1);
	self->priv->_keep_alive = TRUE;
}


static void roxenlauncher_http_request_finalize (GObject* obj) {
	RoxenlauncherHTTPRequest * self;
	self = ROXENLAUNCHER_HTTP_REQUEST (obj);
	_soup_uri_free0 (self->priv->my_uri);
	_g_object_unref0 (self->priv->_headers);
	_g_free0 (self->priv->_http_version);
	G_OBJECT_CLASS (roxenlauncher_http_request_parent_class)->finalize (obj);
}


GType roxenlauncher_http_request_get_type (void) {
	static GType roxenlauncher_http_request_type_id = 0;
	if (roxenlauncher_http_request_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (RoxenlauncherHTTPRequestClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) roxenlauncher_http_request_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RoxenlauncherHTTPRequest), 0, (GInstanceInitFunc) roxenlauncher_http_request_instance_init, NULL };
		roxenlauncher_http_request_type_id = g_type_register_static (G_TYPE_OBJECT, "RoxenlauncherHTTPRequest", &g_define_type_info, 0);
	}
	return roxenlauncher_http_request_type_id;
}


static void roxenlauncher_http_request_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	RoxenlauncherHTTPRequest * self;
	self = ROXENLAUNCHER_HTTP_REQUEST (object);
	switch (property_id) {
		case ROXENLAUNCHER_HTTP_REQUEST_URI:
		g_value_set_boxed (value, roxenlauncher_http_request_get_uri (self));
		break;
		case ROXENLAUNCHER_HTTP_REQUEST_HEADERS:
		g_value_set_object (value, roxenlauncher_http_request_get_headers (self));
		break;
		case ROXENLAUNCHER_HTTP_REQUEST_HTTP_VERSION:
		g_value_set_string (value, roxenlauncher_http_request_get_http_version (self));
		break;
		case ROXENLAUNCHER_HTTP_REQUEST_KEEP_ALIVE:
		g_value_set_boolean (value, roxenlauncher_http_request_get_keep_alive (self));
		break;
		case ROXENLAUNCHER_HTTP_REQUEST_TRACE:
		g_value_set_boolean (value, roxenlauncher_http_request_get_trace (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void roxenlauncher_http_request_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	RoxenlauncherHTTPRequest * self;
	self = ROXENLAUNCHER_HTTP_REQUEST (object);
	switch (property_id) {
		case ROXENLAUNCHER_HTTP_REQUEST_URI:
		roxenlauncher_http_request_set_uri (self, g_value_get_boxed (value));
		break;
		case ROXENLAUNCHER_HTTP_REQUEST_HEADERS:
		roxenlauncher_http_request_set_headers (self, g_value_get_object (value));
		break;
		case ROXENLAUNCHER_HTTP_REQUEST_HTTP_VERSION:
		roxenlauncher_http_request_set_http_version (self, g_value_get_string (value));
		break;
		case ROXENLAUNCHER_HTTP_REQUEST_KEEP_ALIVE:
		roxenlauncher_http_request_set_keep_alive (self, g_value_get_boolean (value));
		break;
		case ROXENLAUNCHER_HTTP_REQUEST_TRACE:
		roxenlauncher_http_request_set_trace (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static guint8* _vala_array_dup1 (guint8* self, int length) {
	return g_memdup (self, length * sizeof (guint8));
}


RoxenlauncherHTTPResponse* roxenlauncher_http_response_construct (GType object_type, GInputStream* stream) {
	GError * _inner_error_;
	RoxenlauncherHTTPResponse * self;
	RoxenlauncherHTTPResponseHttpHeaderField _tmp1_;
	RoxenlauncherHTTPResponseHttpHeaderField _tmp0_ = {0};
	guint8* _tmp2_;
	gint buf_size;
	gint buf_length1;
	guint8* buf;
	g_return_val_if_fail (stream != NULL, NULL);
	_inner_error_ = NULL;
	self = (RoxenlauncherHTTPResponse*) g_object_new (object_type, NULL);
	self->priv->response_result = (_tmp1_ = (_tmp0_.proto = NULL, _tmp0_.version = NULL, _tmp0_.code = 0, _tmp0_.message = NULL, _tmp0_), roxenlauncher_http_response_http_header_field_destroy (&self->priv->response_result), _tmp1_);
	buf = (_tmp2_ = g_new0 (guint8, 1024 * 64), buf_length1 = 1024 * 64, buf_size = buf_length1, _tmp2_);
	{
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gsize read;
				guint8* _tmp8_;
				gint _tmp7_;
				if (!_tmp3_) {
				}
				_tmp3_ = FALSE;
				read = (gsize) g_input_stream_read (stream, buf, (gsize) buf_length1, NULL, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch10_g_error;
					goto __finally10;
				}
				if (read <= 0) {
					break;
				}
				if (read < buf_length1) {
					guint8* _tmp4_;
					gint tmp_size;
					gint tmp_length1;
					guint8* tmp;
					guint8* _tmp6_;
					guint8* _tmp5_;
					tmp = (_tmp4_ = g_new0 (guint8, read), tmp_length1 = read, tmp_size = tmp_length1, _tmp4_);
					memcpy (tmp, buf, read);
					buf = (_tmp6_ = (_tmp5_ = tmp, (_tmp5_ == NULL) ? ((gpointer) _tmp5_) : _vala_array_dup1 (_tmp5_, tmp_length1)), buf = (g_free (buf), NULL), buf_length1 = tmp_length1, buf_size = buf_length1, _tmp6_);
					tmp = (g_free (tmp), NULL);
				}
				self->priv->data_buffer = (_tmp8_ = roxenlauncher_http_concat (self->priv->data_buffer, self->priv->data_buffer_length1, buf, buf_length1, &_tmp7_), self->priv->data_buffer = (g_free (self->priv->data_buffer), NULL), self->priv->data_buffer_length1 = _tmp7_, self->priv->data_buffer_size = self->priv->data_buffer_length1, _tmp8_);
			}
		}
	}
	goto __finally10;
	__catch10_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("http-client.vala:314: Failed to read stream: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally10:
	if (_inner_error_ != NULL) {
		buf = (g_free (buf), NULL);
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	roxenlauncher_http_response_make_defaults (self);
	buf = (g_free (buf), NULL);
	return self;
}


RoxenlauncherHTTPResponse* roxenlauncher_http_response_new (GInputStream* stream) {
	return roxenlauncher_http_response_construct (ROXENLAUNCHER_HTTP_TYPE_RESPONSE, stream);
}


static void roxenlauncher_http_response_make_defaults (RoxenlauncherHTTPResponse* self) {
	char* s;
	char** _tmp4_;
	gint parts_size;
	gint parts_length1;
	char** _tmp3_;
	char** parts;
	guint8* _tmp6_;
	gint _tmp5_;
	g_return_if_fail (self != NULL);
	s = g_strdup ("");
	{
		glong i;
		i = (glong) 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				char* _tmp2_;
				char* _tmp1_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->data_buffer_length1)) {
					break;
				}
				s = (_tmp2_ = g_strconcat (s, _tmp1_ = g_strdup_printf ("%c", (gint) self->priv->data_buffer[i]), NULL), _g_free0 (s), _tmp2_);
				_g_free0 (_tmp1_);
			}
		}
	}
	parts = (_tmp4_ = _tmp3_ = g_strsplit (s, "\r\n\r\n", 2), parts_length1 = _vala_array_length (_tmp3_), parts_size = parts_length1, _tmp4_);
	self->priv->data_buffer = (_tmp6_ = roxenlauncher_http_ltrim_uint8_array (self->priv->data_buffer, self->priv->data_buffer_length1, string_get_length (parts[0]) + 4, &_tmp5_), self->priv->data_buffer = (g_free (self->priv->data_buffer), NULL), self->priv->data_buffer_length1 = _tmp5_, self->priv->data_buffer_size = self->priv->data_buffer_length1, _tmp6_);
	roxenlauncher_http_response_set_data (self, parts[1]);
	roxenlauncher_http_response_parse_headers (self, parts[0]);
	_g_free0 (s);
	parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
}


static char* string_substring (const char* self, glong offset, glong len) {
	char* result;
	glong string_length;
	const char* start;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = g_utf8_strlen (self, -1);
	if (offset < 0) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= 0, NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < 0) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	start = g_utf8_offset_to_pointer (self, offset);
	result = g_strndup (start, ((gchar*) g_utf8_offset_to_pointer (start, len)) - ((gchar*) start));
	return result;
}


static void roxenlauncher_http_response_parse_headers (RoxenlauncherHTTPResponse* self, const char* header) {
	glong i;
	g_return_if_fail (self != NULL);
	g_return_if_fail (header != NULL);
	i = (glong) 0;
	{
		char** _tmp0_;
		char** h_collection;
		int h_collection_length1;
		int h_it;
		h_collection = _tmp0_ = g_strsplit (header, "\r\n", 0);
		h_collection_length1 = _vala_array_length (_tmp0_);
		for (h_it = 0; h_it < _vala_array_length (_tmp0_); h_it = h_it + 1) {
			char* h;
			h = g_strdup (h_collection[h_it]);
			{
				glong pos = 0L;
				i++;
				if (i == 1) {
					if (!roxenlauncher_http_response_http_header_field_parse_line (&self->priv->response_result, h)) {
						g_warning ("http-client.vala:347: Failed to parse HTTP response");
					}
					_g_free0 (h);
					continue;
				}
				if ((pos = roxenlauncher_http_strpos (h, ":")) > (-1)) {
					char* key;
					char* val;
					gboolean _tmp1_ = FALSE;
					key = string_substring (h, (glong) 0, pos);
					val = string_substring (h, pos + 2, -1);
					if (key != NULL) {
						_tmp1_ = val != NULL;
					} else {
						_tmp1_ = FALSE;
					}
					if (_tmp1_) {
						gee_abstract_map_set ((GeeAbstractMap*) self->priv->my_headers, key, val);
					}
					_g_free0 (key);
					_g_free0 (val);
				}
				_g_free0 (h);
			}
		}
		h_collection = (_vala_array_free (h_collection, h_collection_length1, (GDestroyNotify) g_free), NULL);
	}
}


GeeHashMap* roxenlauncher_http_response_get_headers (RoxenlauncherHTTPResponse* self) {
	GeeHashMap* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->my_headers;
	return result;
}


const char* roxenlauncher_http_response_get_data (RoxenlauncherHTTPResponse* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_data;
	return result;
}


static void roxenlauncher_http_response_set_data (RoxenlauncherHTTPResponse* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_data = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_data), _tmp0_);
	g_object_notify ((GObject *) self, "data");
}


guint8* roxenlauncher_http_response_get_raw_data (RoxenlauncherHTTPResponse* self, int* result_length1) {
	guint8* result;
	guint8* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	result = (_tmp0_ = self->priv->data_buffer, *result_length1 = self->priv->data_buffer_length1, _tmp0_);
	return result;
}


const char* roxenlauncher_http_response_get_version (RoxenlauncherHTTPResponse* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->response_result.version;
	return result;
}


gint roxenlauncher_http_response_get_status_code (RoxenlauncherHTTPResponse* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->response_result.code;
	return result;
}


const char* roxenlauncher_http_response_get_status_text (RoxenlauncherHTTPResponse* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->response_result.message;
	return result;
}


gboolean roxenlauncher_http_response_http_header_field_parse_line (RoxenlauncherHTTPResponseHttpHeaderField *self, const char* line) {
	gboolean result;
	GError * _inner_error_;
	g_return_val_if_fail (line != NULL, FALSE);
	_inner_error_ = NULL;
	{
		GRegex* re;
		GMatchInfo* m;
		GMatchInfo* _tmp2_;
		gboolean _tmp1_;
		GMatchInfo* _tmp0_ = NULL;
		re = g_regex_new ("([a-zA-Z]+)/([0-9].[0-9]) ([0-9]+) (.*)", 0, 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch11_g_error;
			goto __finally11;
		}
		m = NULL;
		if ((_tmp1_ = g_regex_match (re, line, G_REGEX_MATCH_ANCHORED, &_tmp0_), m = (_tmp2_ = _tmp0_, _g_match_info_free0 (m), _tmp2_), _tmp1_)) {
			char** _tmp4_;
			gint ss_size;
			gint ss_length1;
			char** _tmp3_;
			char** ss;
			ss = (_tmp4_ = _tmp3_ = g_match_info_fetch_all (m), ss_length1 = _vala_array_length (_tmp3_), ss_size = ss_length1, _tmp4_);
			{
				glong i;
				i = (glong) 0;
				{
					gboolean _tmp5_;
					_tmp5_ = TRUE;
					while (TRUE) {
						if (!_tmp5_) {
							i++;
						}
						_tmp5_ = FALSE;
						if (!(i < ss_length1)) {
							break;
						}
						switch (i) {
							case 1:
							{
								char* _tmp6_;
								(*self).proto = (_tmp6_ = g_strdup (ss[i]), _g_free0 ((*self).proto), _tmp6_);
								break;
							}
							case 2:
							{
								char* _tmp7_;
								(*self).version = (_tmp7_ = g_strdup (ss[i]), _g_free0 ((*self).version), _tmp7_);
								break;
							}
							case 3:
							{
								(*self).code = atoi (ss[i]);
								break;
							}
							case 4:
							{
								char* _tmp8_;
								(*self).message = (_tmp8_ = g_strdup (ss[i]), _g_free0 ((*self).message), _tmp8_);
								break;
							}
						}
					}
				}
			}
			result = TRUE;
			ss = (_vala_array_free (ss, ss_length1, (GDestroyNotify) g_free), NULL);
			_g_regex_unref0 (re);
			_g_match_info_free0 (m);
			return result;
		}
		_g_regex_unref0 (re);
		_g_match_info_free0 (m);
	}
	goto __finally11;
	__catch11_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("http-client.vala:282: Regex error: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally11:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = FALSE;
	return result;
}


void roxenlauncher_http_response_http_header_field_copy (const RoxenlauncherHTTPResponseHttpHeaderField* self, RoxenlauncherHTTPResponseHttpHeaderField* dest) {
	dest->proto = g_strdup (self->proto);
	dest->version = g_strdup (self->version);
	dest->code = self->code;
	dest->message = g_strdup (self->message);
}


void roxenlauncher_http_response_http_header_field_destroy (RoxenlauncherHTTPResponseHttpHeaderField* self) {
	_g_free0 (self->proto);
	_g_free0 (self->version);
	_g_free0 (self->message);
}


RoxenlauncherHTTPResponseHttpHeaderField* roxenlauncher_http_response_http_header_field_dup (const RoxenlauncherHTTPResponseHttpHeaderField* self) {
	RoxenlauncherHTTPResponseHttpHeaderField* dup;
	dup = g_new0 (RoxenlauncherHTTPResponseHttpHeaderField, 1);
	roxenlauncher_http_response_http_header_field_copy (self, dup);
	return dup;
}


void roxenlauncher_http_response_http_header_field_free (RoxenlauncherHTTPResponseHttpHeaderField* self) {
	roxenlauncher_http_response_http_header_field_destroy (self);
	g_free (self);
}


GType roxenlauncher_http_response_http_header_field_get_type (void) {
	static GType roxenlauncher_http_response_http_header_field_type_id = 0;
	if (roxenlauncher_http_response_http_header_field_type_id == 0) {
		roxenlauncher_http_response_http_header_field_type_id = g_boxed_type_register_static ("RoxenlauncherHTTPResponseHttpHeaderField", (GBoxedCopyFunc) roxenlauncher_http_response_http_header_field_dup, (GBoxedFreeFunc) roxenlauncher_http_response_http_header_field_free);
	}
	return roxenlauncher_http_response_http_header_field_type_id;
}


static void roxenlauncher_http_response_class_init (RoxenlauncherHTTPResponseClass * klass) {
	roxenlauncher_http_response_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RoxenlauncherHTTPResponsePrivate));
	G_OBJECT_CLASS (klass)->get_property = roxenlauncher_http_response_get_property;
	G_OBJECT_CLASS (klass)->set_property = roxenlauncher_http_response_set_property;
	G_OBJECT_CLASS (klass)->finalize = roxenlauncher_http_response_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_HTTP_RESPONSE_HEADERS, g_param_spec_object ("headers", "headers", "headers", GEE_TYPE_HASH_MAP, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_HTTP_RESPONSE_DATA, g_param_spec_string ("data", "data", "data", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_HTTP_RESPONSE_VERSION, g_param_spec_string ("version", "version", "version", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_HTTP_RESPONSE_STATUS_CODE, g_param_spec_int ("status-code", "status-code", "status-code", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_HTTP_RESPONSE_STATUS_TEXT, g_param_spec_string ("status-text", "status-text", "status-text", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void roxenlauncher_http_response_instance_init (RoxenlauncherHTTPResponse * self) {
	guint8* _tmp0_ = NULL;
	self->priv = ROXENLAUNCHER_HTTP_RESPONSE_GET_PRIVATE (self);
	self->priv->my_headers = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	self->priv->data_buffer = (_tmp0_ = g_new0 (guint8, 0), _tmp0_);
	self->priv->data_buffer_length1 = 0;
}


static void roxenlauncher_http_response_finalize (GObject* obj) {
	RoxenlauncherHTTPResponse * self;
	self = ROXENLAUNCHER_HTTP_RESPONSE (obj);
	_g_object_unref0 (self->priv->my_headers);
	_g_free0 (self->priv->_data);
	roxenlauncher_http_response_http_header_field_destroy (&self->priv->response_result);
	self->priv->data_buffer = (g_free (self->priv->data_buffer), NULL);
	G_OBJECT_CLASS (roxenlauncher_http_response_parent_class)->finalize (obj);
}


GType roxenlauncher_http_response_get_type (void) {
	static GType roxenlauncher_http_response_type_id = 0;
	if (roxenlauncher_http_response_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (RoxenlauncherHTTPResponseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) roxenlauncher_http_response_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RoxenlauncherHTTPResponse), 0, (GInstanceInitFunc) roxenlauncher_http_response_instance_init, NULL };
		roxenlauncher_http_response_type_id = g_type_register_static (G_TYPE_OBJECT, "RoxenlauncherHTTPResponse", &g_define_type_info, 0);
	}
	return roxenlauncher_http_response_type_id;
}


static void roxenlauncher_http_response_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	RoxenlauncherHTTPResponse * self;
	self = ROXENLAUNCHER_HTTP_RESPONSE (object);
	switch (property_id) {
		case ROXENLAUNCHER_HTTP_RESPONSE_HEADERS:
		g_value_set_object (value, roxenlauncher_http_response_get_headers (self));
		break;
		case ROXENLAUNCHER_HTTP_RESPONSE_DATA:
		g_value_set_string (value, roxenlauncher_http_response_get_data (self));
		break;
		case ROXENLAUNCHER_HTTP_RESPONSE_VERSION:
		g_value_set_string (value, roxenlauncher_http_response_get_version (self));
		break;
		case ROXENLAUNCHER_HTTP_RESPONSE_STATUS_CODE:
		g_value_set_int (value, roxenlauncher_http_response_get_status_code (self));
		break;
		case ROXENLAUNCHER_HTTP_RESPONSE_STATUS_TEXT:
		g_value_set_string (value, roxenlauncher_http_response_get_status_text (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void roxenlauncher_http_response_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	RoxenlauncherHTTPResponse * self;
	self = ROXENLAUNCHER_HTTP_RESPONSE (object);
	switch (property_id) {
		case ROXENLAUNCHER_HTTP_RESPONSE_DATA:
		roxenlauncher_http_response_set_data (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


glong roxenlauncher_http_strpos (const char* haystack, const char* needle) {
	glong result;
	char* tmp;
	g_return_val_if_fail (haystack != NULL, 0L);
	g_return_val_if_fail (needle != NULL, 0L);
	tmp = g_strdup (strstr (haystack, needle));
	if (tmp == NULL) {
		result = (glong) (-1);
		_g_free0 (tmp);
		return result;
	}
	result = string_get_length (haystack) - string_get_length (tmp);
	_g_free0 (tmp);
	return result;
}


guint8* roxenlauncher_http_concat (guint8* all, int all_length1, guint8* tmp, int tmp_length1, int* result_length1) {
	guint8* result;
	guint8* _tmp1_;
	gint n_size;
	gint n_length1;
	gint _tmp0_;
	guint8* n;
	gulong i;
	gulong j;
	guint8* _tmp4_;
	n = (_tmp1_ = g_new0 (guint8, _tmp0_ = all_length1 + tmp_length1), n_length1 = _tmp0_, n_size = n_length1, _tmp1_);
	i = (gulong) 0;
	j = (gulong) 0;
	{
		gboolean _tmp2_;
		_tmp2_ = TRUE;
		while (TRUE) {
			if (!_tmp2_) {
				i++;
			}
			_tmp2_ = FALSE;
			if (!(i < all_length1)) {
				break;
			}
			n[i] = all[i];
		}
	}
	{
		gboolean _tmp3_;
		_tmp3_ = TRUE;
		while (TRUE) {
			if (!_tmp3_) {
				j++;
				i++;
			}
			_tmp3_ = FALSE;
			if (!(j < tmp_length1)) {
				break;
			}
			n[i] = tmp[j];
		}
	}
	result = (_tmp4_ = n, *result_length1 = n_length1, _tmp4_);
	return result;
	n = (g_free (n), NULL);
}


guint8* roxenlauncher_http_ltrim_uint8_array (guint8* array, int array_length1, glong offset, int* result_length1) {
	guint8* result;
	guint8* _tmp1_;
	gint t_size;
	gint t_length1;
	gint _tmp0_;
	guint8* t;
	glong j;
	guint8* _tmp3_;
	t = (_tmp1_ = g_new0 (guint8, _tmp0_ = array_length1 - offset), t_length1 = _tmp0_, t_size = t_length1, _tmp1_);
	j = (glong) 0;
	{
		glong i;
		i = offset;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					i++;
				}
				_tmp2_ = FALSE;
				if (!(i < array_length1)) {
					break;
				}
				t[j++] = array[i];
			}
		}
	}
	result = (_tmp3_ = t, *result_length1 = t_length1, _tmp3_);
	return result;
	t = (g_free (t), NULL);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




