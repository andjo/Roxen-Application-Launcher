/* tools.c generated by valac, the Vala compiler
 * generated from tools.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: t; c-basic-offset: 2; tab-width: 2 -*- */
/*
 * tools.vala
 * Copyright (C) Pontus Ã–stlund 2009 <pontus@poppa.se>
 *
 * This file is part of Roxen Application Launcher (RAL)
 * 
 * RAL is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * RAL is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with RAL.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <glib/gstdio.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <time.h>
#include <glib/gi18n-lib.h>
#include <gee.h>
#include <gtk/gtk.h>
#include <gobject/gvaluecollector.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define ROXENLAUNCHER_TYPE_DATE_TIME (roxenlauncher_date_time_get_type ())
#define ROXENLAUNCHER_DATE_TIME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ROXENLAUNCHER_TYPE_DATE_TIME, RoxenlauncherDateTime))
#define ROXENLAUNCHER_DATE_TIME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ROXENLAUNCHER_TYPE_DATE_TIME, RoxenlauncherDateTimeClass))
#define ROXENLAUNCHER_IS_DATE_TIME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ROXENLAUNCHER_TYPE_DATE_TIME))
#define ROXENLAUNCHER_IS_DATE_TIME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ROXENLAUNCHER_TYPE_DATE_TIME))
#define ROXENLAUNCHER_DATE_TIME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ROXENLAUNCHER_TYPE_DATE_TIME, RoxenlauncherDateTimeClass))

typedef struct _RoxenlauncherDateTime RoxenlauncherDateTime;
typedef struct _RoxenlauncherDateTimeClass RoxenlauncherDateTimeClass;
typedef struct _RoxenlauncherDateTimePrivate RoxenlauncherDateTimePrivate;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

#define ROXENLAUNCHER_TYPE_SIMPLE_URI (roxenlauncher_simple_uri_get_type ())
#define ROXENLAUNCHER_SIMPLE_URI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ROXENLAUNCHER_TYPE_SIMPLE_URI, RoxenlauncherSimpleURI))
#define ROXENLAUNCHER_SIMPLE_URI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ROXENLAUNCHER_TYPE_SIMPLE_URI, RoxenlauncherSimpleURIClass))
#define ROXENLAUNCHER_IS_SIMPLE_URI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ROXENLAUNCHER_TYPE_SIMPLE_URI))
#define ROXENLAUNCHER_IS_SIMPLE_URI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ROXENLAUNCHER_TYPE_SIMPLE_URI))
#define ROXENLAUNCHER_SIMPLE_URI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ROXENLAUNCHER_TYPE_SIMPLE_URI, RoxenlauncherSimpleURIClass))

typedef struct _RoxenlauncherSimpleURI RoxenlauncherSimpleURI;
typedef struct _RoxenlauncherSimpleURIClass RoxenlauncherSimpleURIClass;
typedef struct _RoxenlauncherSimpleURIPrivate RoxenlauncherSimpleURIPrivate;
#define _g_match_info_free0(var) ((var == NULL) ? NULL : (var = (g_match_info_free (var), NULL)))

#define ROXENLAUNCHER_TYPE_ALERT (roxenlauncher_alert_get_type ())
#define ROXENLAUNCHER_ALERT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ROXENLAUNCHER_TYPE_ALERT, RoxenlauncherAlert))
#define ROXENLAUNCHER_ALERT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ROXENLAUNCHER_TYPE_ALERT, RoxenlauncherAlertClass))
#define ROXENLAUNCHER_IS_ALERT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ROXENLAUNCHER_TYPE_ALERT))
#define ROXENLAUNCHER_IS_ALERT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ROXENLAUNCHER_TYPE_ALERT))
#define ROXENLAUNCHER_ALERT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ROXENLAUNCHER_TYPE_ALERT, RoxenlauncherAlertClass))

typedef struct _RoxenlauncherAlert RoxenlauncherAlert;
typedef struct _RoxenlauncherAlertClass RoxenlauncherAlertClass;
typedef struct _RoxenlauncherAlertPrivate RoxenlauncherAlertPrivate;
typedef struct _RoxenlauncherParamSpecAlert RoxenlauncherParamSpecAlert;

typedef enum  {
	ROXENLAUNCHER_ROXEN_ERROR_BAD_LAUNCHERFILE,
	ROXENLAUNCHER_ROXEN_ERROR_GENERIC
} RoxenlauncherRoxenError;
#define ROXENLAUNCHER_ROXEN_ERROR roxenlauncher_roxen_error_quark ()
struct _RoxenlauncherDateTime {
	GObject parent_instance;
	RoxenlauncherDateTimePrivate * priv;
};

struct _RoxenlauncherDateTimeClass {
	GObjectClass parent_class;
};

struct _RoxenlauncherDateTimePrivate {
	GTimeVal tv;
	struct tm time;
};

struct _RoxenlauncherSimpleURI {
	GObject parent_instance;
	RoxenlauncherSimpleURIPrivate * priv;
};

struct _RoxenlauncherSimpleURIClass {
	GObjectClass parent_class;
};

struct _RoxenlauncherSimpleURIPrivate {
	char* _scheme;
	char* _host;
	char* _username;
	char* _password;
	gint _port;
	char* _path;
	char* _query;
	char* _fragment;
};

struct _RoxenlauncherAlert {
	GTypeInstance parent_instance;
	volatile int ref_count;
	RoxenlauncherAlertPrivate * priv;
};

struct _RoxenlauncherAlertClass {
	GTypeClass parent_class;
	void (*finalize) (RoxenlauncherAlert *self);
};

struct _RoxenlauncherParamSpecAlert {
	GParamSpec parent_instance;
};


static gpointer roxenlauncher_date_time_parent_class = NULL;
static GRegex* roxenlauncher_simple_uri_re;
static GRegex* roxenlauncher_simple_uri_re = NULL;
static GeeHashMap* roxenlauncher_simple_uri__ports;
static GeeHashMap* roxenlauncher_simple_uri__ports = NULL;
static gpointer roxenlauncher_simple_uri_parent_class = NULL;
static gpointer roxenlauncher_alert_parent_class = NULL;

GQuark roxenlauncher_roxen_error_quark (void);
char* roxenlauncher_file_get_contents (const char* file);
gboolean roxenlauncher_file_exists (const char* file);
char* roxenlauncher_implode (char** s, int s_length1, const char* glue);
static void _vala_array_add2 (char*** array, int* length, int* size, char* value);
char** roxenlauncher_slice (char** s, int s_length1, guint from, guint to, int* result_length1, GError** error);
char* roxenlauncher_rtrim (const char* s, const char* tail);
char* roxenlauncher_ltrim (const char* s, const char* head);
char* roxenlauncher_trim (const char* s, const char* chars);
GType roxenlauncher_date_time_get_type (void);
RoxenlauncherDateTime* roxenlauncher_date_time_timeval (GTimeVal* timeval);
RoxenlauncherDateTime* roxenlauncher_filemtime (const char* path);
RoxenlauncherDateTime* roxenlauncher_date_time_unixtime (time_t timestamp);
RoxenlauncherDateTime* roxenlauncher_filectime (const char* path);
char* roxenlauncher_getdir (const char* which);
#define ROXENLAUNCHER_APP_DIR ".roxenlauncher"
#define ROXENLAUNCHER_APP_FILES_DIR "files"
#define ROXENLAUNCHER_DATE_TIME_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ROXENLAUNCHER_TYPE_DATE_TIME, RoxenlauncherDateTimePrivate))
enum  {
	ROXENLAUNCHER_DATE_TIME_DUMMY_PROPERTY
};
RoxenlauncherDateTime* roxenlauncher_date_time_new_from_now (void);
RoxenlauncherDateTime* roxenlauncher_date_time_construct_from_now (GType object_type);
RoxenlauncherDateTime* roxenlauncher_date_time_now (void);
RoxenlauncherDateTime* roxenlauncher_date_time_new_from_unixtime (time_t unixtime);
RoxenlauncherDateTime* roxenlauncher_date_time_construct_from_unixtime (GType object_type, time_t unixtime);
RoxenlauncherDateTime* roxenlauncher_date_time_new_from_timeval (GTimeVal* timeval);
RoxenlauncherDateTime* roxenlauncher_date_time_construct_from_timeval (GType object_type, GTimeVal* timeval);
RoxenlauncherDateTime* roxenlauncher_date_time_new (guint year, guint month, guint date, guint hour, guint minute, guint second);
RoxenlauncherDateTime* roxenlauncher_date_time_construct (GType object_type, guint year, guint month, guint date, guint hour, guint minute, guint second);
char* roxenlauncher_date_time_format (RoxenlauncherDateTime* self, const char* fmt);
char* roxenlauncher_date_time_to_string (RoxenlauncherDateTime* self);
char* roxenlauncher_date_time_to_iso8601 (RoxenlauncherDateTime* self);
time_t roxenlauncher_date_time_to_unixtime (RoxenlauncherDateTime* self);
static void roxenlauncher_date_time_finalize (GObject* obj);
GType roxenlauncher_simple_uri_get_type (void);
#define ROXENLAUNCHER_SIMPLE_URI_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ROXENLAUNCHER_TYPE_SIMPLE_URI, RoxenlauncherSimpleURIPrivate))
enum  {
	ROXENLAUNCHER_SIMPLE_URI_DUMMY_PROPERTY,
	ROXENLAUNCHER_SIMPLE_URI_SCHEME,
	ROXENLAUNCHER_SIMPLE_URI_HOST,
	ROXENLAUNCHER_SIMPLE_URI_USERNAME,
	ROXENLAUNCHER_SIMPLE_URI_PASSWORD,
	ROXENLAUNCHER_SIMPLE_URI_PORT,
	ROXENLAUNCHER_SIMPLE_URI_PATH,
	ROXENLAUNCHER_SIMPLE_URI_QUERY,
	ROXENLAUNCHER_SIMPLE_URI_FRAGMENT
};
void roxenlauncher_simple_uri_set_scheme (RoxenlauncherSimpleURI* self, const char* value);
void roxenlauncher_simple_uri_set_username (RoxenlauncherSimpleURI* self, const char* value);
void roxenlauncher_simple_uri_set_password (RoxenlauncherSimpleURI* self, const char* value);
void roxenlauncher_simple_uri_set_host (RoxenlauncherSimpleURI* self, const char* value);
void roxenlauncher_simple_uri_set_port (RoxenlauncherSimpleURI* self, gint value);
void roxenlauncher_simple_uri_set_path (RoxenlauncherSimpleURI* self, const char* value);
void roxenlauncher_simple_uri_set_query (RoxenlauncherSimpleURI* self, const char* value);
void roxenlauncher_simple_uri_set_fragment (RoxenlauncherSimpleURI* self, const char* value);
gint roxenlauncher_simple_uri_get_port (RoxenlauncherSimpleURI* self);
GeeHashMap* roxenlauncher_simple_uri_ports (void);
const char* roxenlauncher_simple_uri_get_scheme (RoxenlauncherSimpleURI* self);
RoxenlauncherSimpleURI* roxenlauncher_simple_uri_new (const char* uri);
RoxenlauncherSimpleURI* roxenlauncher_simple_uri_construct (GType object_type, const char* uri);
const char* roxenlauncher_simple_uri_get_host (RoxenlauncherSimpleURI* self);
const char* roxenlauncher_simple_uri_get_username (RoxenlauncherSimpleURI* self);
const char* roxenlauncher_simple_uri_get_password (RoxenlauncherSimpleURI* self);
const char* roxenlauncher_simple_uri_get_path (RoxenlauncherSimpleURI* self);
const char* roxenlauncher_simple_uri_get_query (RoxenlauncherSimpleURI* self);
const char* roxenlauncher_simple_uri_get_fragment (RoxenlauncherSimpleURI* self);
static void roxenlauncher_simple_uri_finalize (GObject* obj);
static void roxenlauncher_simple_uri_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void roxenlauncher_simple_uri_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
gpointer roxenlauncher_alert_ref (gpointer instance);
void roxenlauncher_alert_unref (gpointer instance);
GParamSpec* roxenlauncher_param_spec_alert (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void roxenlauncher_value_set_alert (GValue* value, gpointer v_object);
gpointer roxenlauncher_value_get_alert (const GValue* value);
GType roxenlauncher_alert_get_type (void);
enum  {
	ROXENLAUNCHER_ALERT_DUMMY_PROPERTY
};
gboolean roxenlauncher_alert_confirm (GtkWindow* parent, const char* message);
RoxenlauncherAlert* roxenlauncher_alert_new (void);
RoxenlauncherAlert* roxenlauncher_alert_construct (GType object_type);
static void roxenlauncher_alert_finalize (RoxenlauncherAlert* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);



GQuark roxenlauncher_roxen_error_quark (void) {
	return g_quark_from_static_string ("roxenlauncher_roxen_error-quark");
}


char* roxenlauncher_file_get_contents (const char* file) {
	char* result;
	GError * _inner_error_;
	char* output;
	g_return_val_if_fail (file != NULL, NULL);
	_inner_error_ = NULL;
	if (!g_file_test (file, G_FILE_TEST_EXISTS)) {
		g_warning ("tools.vala:37: No such file: %s", file);
		result = NULL;
		return result;
	}
	output = NULL;
	{
		char* _tmp2_;
		gboolean _tmp1_;
		char* _tmp0_ = NULL;
		_tmp1_ = g_file_get_contents (file, &_tmp0_, NULL, &_inner_error_);
		output = (_tmp2_ = _tmp0_, _g_free0 (output), _tmp2_);
		_tmp1_;
		if (_inner_error_ != NULL) {
			goto __catch18_g_error;
			goto __finally18;
		}
	}
	goto __finally18;
	__catch18_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("tools.vala:44: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally18:
	if (_inner_error_ != NULL) {
		_g_free0 (output);
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = output;
	return result;
}


gboolean roxenlauncher_file_exists (const char* file) {
	gboolean result;
	g_return_val_if_fail (file != NULL, FALSE);
	result = g_file_test (file, G_FILE_TEST_EXISTS);
	return result;
}


char* roxenlauncher_implode (char** s, int s_length1, const char* glue) {
	char* result;
	glong len;
	char* str;
	g_return_val_if_fail (glue != NULL, NULL);
	len = (glong) s_length1;
	str = g_strdup ("");
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				char* _tmp1_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < len)) {
					break;
				}
				str = (_tmp1_ = g_strconcat (str, s[i], NULL), _g_free0 (str), _tmp1_);
				if (i < (len - 1)) {
					char* _tmp2_;
					str = (_tmp2_ = g_strconcat (str, glue, NULL), _g_free0 (str), _tmp2_);
				}
			}
		}
	}
	result = str;
	return result;
}


static void _vala_array_add2 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


char** roxenlauncher_slice (char** s, int s_length1, guint from, guint to, int* result_length1, GError** error) {
	char** result;
	GError * _inner_error_;
	char** _tmp1_;
	gint ss_size;
	gint ss_length1;
	char** _tmp0_ = NULL;
	char** ss;
	guint limit;
	char** _tmp3_;
	_inner_error_ = NULL;
	if (to == 0) {
		to = s_length1 - from;
	}
	if ((from + to) > s_length1) {
		_inner_error_ = g_error_new_literal (ROXENLAUNCHER_ROXEN_ERROR, ROXENLAUNCHER_ROXEN_ERROR_GENERIC, "slice(): Index is out of range");
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == ROXENLAUNCHER_ROXEN_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	ss = (_tmp1_ = (_tmp0_ = g_new0 (char*, 0 + 1), _tmp0_), ss_length1 = 0, ss_size = ss_length1, _tmp1_);
	limit = from + to;
	{
		guint i;
		i = from;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					i++;
				}
				_tmp2_ = FALSE;
				if (!(i < limit)) {
					break;
				}
				_vala_array_add2 (&ss, &ss_length1, &ss_size, g_strdup (s[i]));
			}
		}
	}
	result = (_tmp3_ = ss, *result_length1 = ss_length1, _tmp3_);
	return result;
	ss = (_vala_array_free (ss, ss_length1, (GDestroyNotify) g_free), NULL);
}


static char* string_chomp (const char* self) {
	char* result;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strchomp (_result_);
	result = _result_;
	return result;
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, -1);
	return result;
}


static char* string_substring (const char* self, glong offset, glong len) {
	char* result;
	glong string_length;
	const char* start;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = g_utf8_strlen (self, -1);
	if (offset < 0) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= 0, NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < 0) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	start = g_utf8_offset_to_pointer (self, offset);
	result = g_strndup (start, ((gchar*) g_utf8_offset_to_pointer (start, len)) - ((gchar*) start));
	return result;
}


char* roxenlauncher_rtrim (const char* s, const char* tail) {
	char* result;
	char* str;
	glong len;
	g_return_val_if_fail (s != NULL, NULL);
	g_return_val_if_fail (tail != NULL, NULL);
	if (_vala_strcmp0 (tail, "") == 0) {
		result = string_chomp (s);
		return result;
	}
	str = g_strdup (s);
	len = string_get_length (tail);
	while (TRUE) {
		char* _tmp0_;
		if (!g_str_has_suffix (str, tail)) {
			break;
		}
		str = (_tmp0_ = string_substring (str, (glong) 0, string_get_length (str) - len), _g_free0 (str), _tmp0_);
	}
	result = str;
	return result;
}


static char* string_chug (const char* self) {
	char* result;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strchug (_result_);
	result = _result_;
	return result;
}


char* roxenlauncher_ltrim (const char* s, const char* head) {
	char* result;
	char* str;
	glong len;
	g_return_val_if_fail (s != NULL, NULL);
	g_return_val_if_fail (head != NULL, NULL);
	if (_vala_strcmp0 (head, "") == 0) {
		result = string_chug (s);
		return result;
	}
	str = g_strdup (s);
	len = string_get_length (head);
	while (TRUE) {
		char* _tmp0_;
		if (!g_str_has_prefix (str, head)) {
			break;
		}
		str = (_tmp0_ = string_substring (str, len, -1), _g_free0 (str), _tmp0_);
	}
	result = str;
	return result;
}


static char* string_strip (const char* self) {
	char* result;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


char* roxenlauncher_trim (const char* s, const char* chars) {
	char* result;
	char* _tmp0_;
	char* _tmp1_;
	g_return_val_if_fail (s != NULL, NULL);
	g_return_val_if_fail (chars != NULL, NULL);
	if (_vala_strcmp0 (chars, "") == 0) {
		result = string_strip (s);
		return result;
	}
	result = (_tmp1_ = roxenlauncher_ltrim (_tmp0_ = roxenlauncher_rtrim (s, chars), chars), _g_free0 (_tmp0_), _tmp1_);
	return result;
}


RoxenlauncherDateTime* roxenlauncher_filemtime (const char* path) {
	RoxenlauncherDateTime* result;
	GError * _inner_error_;
	g_return_val_if_fail (path != NULL, NULL);
	_inner_error_ = NULL;
	{
		GFile* f;
		f = g_file_new_for_path (path);
		if (g_file_query_exists (f, NULL)) {
			GFileInfo* fi;
			GTimeVal tv = {0};
			fi = g_file_query_info (f, G_FILE_ATTRIBUTE_TIME_MODIFIED, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (f);
				goto __catch19_g_error;
				goto __finally19;
			}
			g_file_info_get_modification_time (fi, &tv);
			result = roxenlauncher_date_time_timeval (&tv);
			_g_object_unref0 (fi);
			_g_object_unref0 (f);
			return result;
		}
		_g_object_unref0 (f);
	}
	goto __finally19;
	__catch19_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("tools.vala:128: get_fileinfo(): %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally19:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	return result;
}


RoxenlauncherDateTime* roxenlauncher_filectime (const char* path) {
	RoxenlauncherDateTime* result;
	GError * _inner_error_;
	g_return_val_if_fail (path != NULL, NULL);
	_inner_error_ = NULL;
	{
		GFile* f;
		f = g_file_new_for_path (path);
		if (g_file_query_exists (f, NULL)) {
			GFileInfo* fi;
			guint64 ts;
			fi = g_file_query_info (f, G_FILE_ATTRIBUTE_TIME_CREATED, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (f);
				goto __catch20_g_error;
				goto __finally20;
			}
			ts = g_file_info_get_attribute_uint64 (fi, G_FILE_ATTRIBUTE_TIME_CREATED);
			result = roxenlauncher_date_time_unixtime ((time_t) ts);
			_g_object_unref0 (fi);
			_g_object_unref0 (f);
			return result;
		}
		_g_object_unref0 (f);
	}
	goto __finally20;
	__catch20_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("tools.vala:147: get_fileinfo(): %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally20:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	return result;
}


char* roxenlauncher_getdir (const char* which) {
	char* result;
	GQuark _tmp5_;
	char* _tmp4_;
	static GQuark _tmp5__label0 = 0;
	static GQuark _tmp5__label1 = 0;
	static GQuark _tmp5__label2 = 0;
	static GQuark _tmp5__label3 = 0;
	static GQuark _tmp5__label4 = 0;
	g_return_val_if_fail (which != NULL, NULL);
	_tmp4_ = g_utf8_strup (which, -1);
	_tmp5_ = (NULL == _tmp4_) ? 0 : g_quark_from_string (_tmp4_);
	g_free (_tmp4_);
	if (_tmp5_ == ((0 != _tmp5__label0) ? _tmp5__label0 : (_tmp5__label0 = g_quark_from_static_string ("$CURRENT"))))
	do {
		result = g_get_current_dir ();
		return result;
	} while (0); else if (_tmp5_ == ((0 != _tmp5__label1) ? _tmp5__label1 : (_tmp5__label1 = g_quark_from_static_string ("$HOME"))))
	do {
		result = g_strdup (g_get_home_dir ());
		return result;
	} while (0); else if (_tmp5_ == ((0 != _tmp5__label2) ? _tmp5__label2 : (_tmp5__label2 = g_quark_from_static_string ("$TMP"))))
	do {
		result = g_strdup (g_get_tmp_dir ());
		return result;
	} while (0); else if (_tmp5_ == ((0 != _tmp5__label3) ? _tmp5__label3 : (_tmp5__label3 = g_quark_from_static_string ("APPLICATION"))))
	do {
		char* _tmp0_;
		char* _tmp1_;
		char* f;
		f = (_tmp1_ = g_build_filename (_tmp0_ = roxenlauncher_getdir ("$home"), ROXENLAUNCHER_APP_DIR, NULL), _g_free0 (_tmp0_), _tmp1_);
		if (!g_file_test (f, G_FILE_TEST_EXISTS)) {
			if (g_mkdir (f, 0750) == (-1)) {
				g_error ("tools.vala:165: %s", _ ("Unable to create local directory"));
			}
		}
		result = f;
		return result;
	} while (0); else if (_tmp5_ == ((0 != _tmp5__label4) ? _tmp5__label4 : (_tmp5__label4 = g_quark_from_static_string ("FILES"))))
	do {
		char* _tmp2_;
		char* _tmp3_;
		char* f;
		f = (_tmp3_ = g_build_filename (_tmp2_ = roxenlauncher_getdir ("$home"), ROXENLAUNCHER_APP_DIR, ROXENLAUNCHER_APP_FILES_DIR, NULL), _g_free0 (_tmp2_), _tmp3_);
		if (!g_file_test (f, G_FILE_TEST_EXISTS)) {
			if (g_mkdir_with_parents (f, 0750) == (-1)) {
				g_error ("tools.vala:174: %s", _ ("Unable to create local directory"));
			}
		}
		result = f;
		return result;
	} while (0);
	result = NULL;
	return result;
}


RoxenlauncherDateTime* roxenlauncher_date_time_now (void) {
	RoxenlauncherDateTime* result;
	result = roxenlauncher_date_time_new_from_now ();
	return result;
}


RoxenlauncherDateTime* roxenlauncher_date_time_unixtime (time_t timestamp) {
	RoxenlauncherDateTime* result;
	result = roxenlauncher_date_time_new_from_unixtime (timestamp);
	return result;
}


RoxenlauncherDateTime* roxenlauncher_date_time_timeval (GTimeVal* timeval) {
	RoxenlauncherDateTime* result;
	result = roxenlauncher_date_time_new_from_timeval (timeval);
	return result;
}


static char* g_time_format (struct tm *self, const char* format) {
	char* result;
	gchar* _tmp0_;
	gint buffer_size;
	gint buffer_length1;
	gchar* buffer;
	g_return_val_if_fail (format != NULL, NULL);
	buffer = (_tmp0_ = g_new0 (gchar, 64), buffer_length1 = 64, buffer_size = buffer_length1, _tmp0_);
	strftime (buffer, buffer_length1, format, &(*self));
	result = g_strdup ((const char*) buffer);
	buffer = (g_free (buffer), NULL);
	return result;
}


static char* string_replace (const char* self, const char* old, const char* replacement) {
	char* result;
	GError * _inner_error_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	_inner_error_ = NULL;
	{
		char* _tmp0_;
		GRegex* _tmp1_;
		GRegex* regex;
		char* _tmp2_;
		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch21_g_regex_error;
			}
			goto __finally21;
		}
		_tmp2_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch21_g_regex_error;
			}
			goto __finally21;
		}
		result = _tmp2_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally21;
	__catch21_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_assert_not_reached ();
			_g_error_free0 (e);
		}
	}
	__finally21:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


RoxenlauncherDateTime* roxenlauncher_date_time_construct (GType object_type, guint year, guint month, guint date, guint hour, guint minute, guint second) {
	RoxenlauncherDateTime * self;
	char* a;
	char* s;
	struct tm _tmp0_ = {0};
	char* _tmp2_;
	char* _tmp1_;
	self = (RoxenlauncherDateTime*) g_object_new (object_type, NULL);
	a = g_strdup_printf ("%ld-%ld-%ld %ld:%ld:%ld", (glong) year, (glong) month, (glong) date, (glong) hour, (glong) minute, (glong) second);
	s = g_strdup ("%Y-%m-%d %T.000000Z");
	self->priv->time = (memset (&_tmp0_, 0, sizeof (struct tm)), _tmp0_);
	strptime (a, s, &self->priv->time);
	g_time_val_from_iso8601 (_tmp2_ = string_replace (_tmp1_ = g_time_format (&self->priv->time, s), " ", "T"), &self->priv->tv);
	_g_free0 (_tmp2_);
	_g_free0 (_tmp1_);
	_g_free0 (a);
	_g_free0 (s);
	return self;
}


RoxenlauncherDateTime* roxenlauncher_date_time_new (guint year, guint month, guint date, guint hour, guint minute, guint second) {
	return roxenlauncher_date_time_construct (ROXENLAUNCHER_TYPE_DATE_TIME, year, month, date, hour, minute, second);
}


static void g_time_local (time_t time, struct tm* result) {
	struct tm _result_ = {0};
	localtime_r (&time, &_result_);
	*result = _result_;
	return;
}


RoxenlauncherDateTime* roxenlauncher_date_time_construct_from_now (GType object_type) {
	RoxenlauncherDateTime * self;
	struct tm _tmp0_ = {0};
	self = (RoxenlauncherDateTime*) g_object_new (object_type, NULL);
	g_get_current_time (&self->priv->tv);
	self->priv->time = (g_time_local ((time_t) self->priv->tv.tv_sec, &_tmp0_), _tmp0_);
	return self;
}


RoxenlauncherDateTime* roxenlauncher_date_time_new_from_now (void) {
	return roxenlauncher_date_time_construct_from_now (ROXENLAUNCHER_TYPE_DATE_TIME);
}


RoxenlauncherDateTime* roxenlauncher_date_time_construct_from_unixtime (GType object_type, time_t unixtime) {
	RoxenlauncherDateTime * self;
	struct tm _tmp0_ = {0};
	self = (RoxenlauncherDateTime*) g_object_new (object_type, NULL);
	self->priv->time = (g_time_local (unixtime, &_tmp0_), _tmp0_);
	self->priv->tv.tv_sec = (glong) mktime (&self->priv->time);
	return self;
}


RoxenlauncherDateTime* roxenlauncher_date_time_new_from_unixtime (time_t unixtime) {
	return roxenlauncher_date_time_construct_from_unixtime (ROXENLAUNCHER_TYPE_DATE_TIME, unixtime);
}


RoxenlauncherDateTime* roxenlauncher_date_time_construct_from_timeval (GType object_type, GTimeVal* timeval) {
	RoxenlauncherDateTime * self;
	struct tm _tmp0_ = {0};
	self = (RoxenlauncherDateTime*) g_object_new (object_type, NULL);
	self->priv->tv = *timeval;
	self->priv->time = (g_time_local ((time_t) self->priv->tv.tv_sec, &_tmp0_), _tmp0_);
	return self;
}


RoxenlauncherDateTime* roxenlauncher_date_time_new_from_timeval (GTimeVal* timeval) {
	return roxenlauncher_date_time_construct_from_timeval (ROXENLAUNCHER_TYPE_DATE_TIME, timeval);
}


char* roxenlauncher_date_time_format (RoxenlauncherDateTime* self, const char* fmt) {
	char* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (fmt != NULL, NULL);
	result = g_time_format (&self->priv->time, fmt);
	return result;
}


static char* g_time_to_string (struct tm *self) {
	char* result;
	result = g_strdup_printf ("%04d-%02d-%02d %02d:%02d:%02d", (*self).tm_year + 1900, (*self).tm_mon + 1, (*self).tm_mday, (*self).tm_hour, (*self).tm_min, (*self).tm_sec);
	return result;
}


char* roxenlauncher_date_time_to_string (RoxenlauncherDateTime* self) {
	char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = g_time_to_string (&self->priv->time);
	return result;
}


char* roxenlauncher_date_time_to_iso8601 (RoxenlauncherDateTime* self) {
	char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = g_time_val_to_iso8601 (&self->priv->tv);
	return result;
}


time_t roxenlauncher_date_time_to_unixtime (RoxenlauncherDateTime* self) {
	time_t result;
	result = mktime (&self->priv->time);
	return result;
}


static void roxenlauncher_date_time_class_init (RoxenlauncherDateTimeClass * klass) {
	roxenlauncher_date_time_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RoxenlauncherDateTimePrivate));
	G_OBJECT_CLASS (klass)->finalize = roxenlauncher_date_time_finalize;
}


static void roxenlauncher_date_time_instance_init (RoxenlauncherDateTime * self) {
	GTimeVal _tmp0_ = {0};
	self->priv = ROXENLAUNCHER_DATE_TIME_GET_PRIVATE (self);
	self->priv->tv = (g_get_current_time (&_tmp0_), _tmp0_);
}


static void roxenlauncher_date_time_finalize (GObject* obj) {
	RoxenlauncherDateTime * self;
	self = ROXENLAUNCHER_DATE_TIME (obj);
	G_OBJECT_CLASS (roxenlauncher_date_time_parent_class)->finalize (obj);
}


GType roxenlauncher_date_time_get_type (void) {
	static GType roxenlauncher_date_time_type_id = 0;
	if (roxenlauncher_date_time_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (RoxenlauncherDateTimeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) roxenlauncher_date_time_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RoxenlauncherDateTime), 0, (GInstanceInitFunc) roxenlauncher_date_time_instance_init, NULL };
		roxenlauncher_date_time_type_id = g_type_register_static (G_TYPE_OBJECT, "RoxenlauncherDateTime", &g_define_type_info, 0);
	}
	return roxenlauncher_date_time_type_id;
}


RoxenlauncherSimpleURI* roxenlauncher_simple_uri_construct (GType object_type, const char* uri) {
	GError * _inner_error_;
	RoxenlauncherSimpleURI * self;
	GMatchInfo* m;
	GMatchInfo* _tmp4_;
	gboolean _tmp3_;
	GMatchInfo* _tmp2_ = NULL;
	g_return_val_if_fail (uri != NULL, NULL);
	_inner_error_ = NULL;
	self = (RoxenlauncherSimpleURI*) g_object_new (object_type, NULL);
	if (roxenlauncher_simple_uri_re == NULL) {
		{
			GRegex* _tmp0_;
			GRegex* _tmp1_;
			_tmp0_ = g_regex_new ("([-+a-zA-Z0-9]+)://" "((.[^:]*):?(.*)?@)?" "(.[^:/]*)" ":?([0-9]{1,6})?" "(/.[^?#]*)" "[?]?(.[^#]*)?" "#?(.*)?", 0, 0, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch22_g_error;
				goto __finally22;
			}
			roxenlauncher_simple_uri_re = (_tmp1_ = _tmp0_, _g_regex_unref0 (roxenlauncher_simple_uri_re), _tmp1_);
		}
		goto __finally22;
		__catch22_g_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				g_warning ("tools.vala:334: Regex error: %s", e->message);
				_g_error_free0 (e);
				return self;
			}
		}
		__finally22:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	m = NULL;
	if ((_tmp3_ = g_regex_match (roxenlauncher_simple_uri_re, uri, G_REGEX_MATCH_ANCHORED, &_tmp2_), m = (_tmp4_ = _tmp2_, _g_match_info_free0 (m), _tmp4_), _tmp3_)) {
		char** _tmp6_;
		gint ss_size;
		gint ss_length1;
		char** _tmp5_;
		char** ss;
		gint i;
		ss = (_tmp6_ = _tmp5_ = g_match_info_fetch_all (m), ss_length1 = _vala_array_length (_tmp5_), ss_size = ss_length1, _tmp6_);
		i = 0;
		{
			char** s_collection;
			int s_collection_length1;
			int s_it;
			s_collection = ss;
			s_collection_length1 = ss_length1;
			for (s_it = 0; s_it < ss_length1; s_it = s_it + 1) {
				char* s;
				s = g_strdup (s_collection[s_it]);
				{
					if (string_get_length (s) == 0) {
						i++;
						_g_free0 (s);
						continue;
					}
					switch (i) {
						case 1:
						{
							char* _tmp7_;
							roxenlauncher_simple_uri_set_scheme (self, _tmp7_ = g_utf8_strdown (s, -1));
							_g_free0 (_tmp7_);
							break;
						}
						case 2:
						{
							break;
						}
						case 3:
						{
							roxenlauncher_simple_uri_set_username (self, s);
							break;
						}
						case 4:
						{
							roxenlauncher_simple_uri_set_password (self, s);
							break;
						}
						case 5:
						{
							char* _tmp8_;
							roxenlauncher_simple_uri_set_host (self, _tmp8_ = g_utf8_strdown (s, -1));
							_g_free0 (_tmp8_);
							break;
						}
						case 6:
						{
							roxenlauncher_simple_uri_set_port (self, atoi (s));
							break;
						}
						case 7:
						{
							roxenlauncher_simple_uri_set_path (self, s);
							break;
						}
						case 8:
						{
							roxenlauncher_simple_uri_set_query (self, s);
							break;
						}
						case 9:
						{
							roxenlauncher_simple_uri_set_fragment (self, s);
							break;
						}
					}
					i++;
					_g_free0 (s);
				}
			}
		}
		if (self->priv->_port == 0) {
			GeeHashMap* _tmp9_;
			_tmp9_ = roxenlauncher_simple_uri_ports ();
			_g_object_unref0 (_tmp9_);
			roxenlauncher_simple_uri_set_port (self, GPOINTER_TO_INT (gee_abstract_map_get ((GeeAbstractMap*) roxenlauncher_simple_uri__ports, self->priv->_scheme)));
		}
		ss = (_vala_array_free (ss, ss_length1, (GDestroyNotify) g_free), NULL);
	} else {
		g_warning ("tools.vala:371: Bad URI(%s)", uri);
	}
	_g_match_info_free0 (m);
	return self;
}


RoxenlauncherSimpleURI* roxenlauncher_simple_uri_new (const char* uri) {
	return roxenlauncher_simple_uri_construct (ROXENLAUNCHER_TYPE_SIMPLE_URI, uri);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GeeHashMap* roxenlauncher_simple_uri_ports (void) {
	GeeHashMap* result;
	if (roxenlauncher_simple_uri__ports == NULL) {
		GeeHashMap* _tmp0_;
		roxenlauncher_simple_uri__ports = (_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_INT, NULL, NULL, NULL, NULL, NULL), _g_object_unref0 (roxenlauncher_simple_uri__ports), _tmp0_);
		gee_abstract_map_set ((GeeAbstractMap*) roxenlauncher_simple_uri__ports, "ftp", GINT_TO_POINTER (21));
		gee_abstract_map_set ((GeeAbstractMap*) roxenlauncher_simple_uri__ports, "ssh", GINT_TO_POINTER (22));
		gee_abstract_map_set ((GeeAbstractMap*) roxenlauncher_simple_uri__ports, "telnet", GINT_TO_POINTER (23));
		gee_abstract_map_set ((GeeAbstractMap*) roxenlauncher_simple_uri__ports, "smtp", GINT_TO_POINTER (25));
		gee_abstract_map_set ((GeeAbstractMap*) roxenlauncher_simple_uri__ports, "http", GINT_TO_POINTER (80));
		gee_abstract_map_set ((GeeAbstractMap*) roxenlauncher_simple_uri__ports, "https", GINT_TO_POINTER (443));
	}
	result = _g_object_ref0 (roxenlauncher_simple_uri__ports);
	return result;
}


const char* roxenlauncher_simple_uri_get_scheme (RoxenlauncherSimpleURI* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_scheme;
	return result;
}


void roxenlauncher_simple_uri_set_scheme (RoxenlauncherSimpleURI* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_scheme = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_scheme), _tmp0_);
	g_object_notify ((GObject *) self, "scheme");
}


const char* roxenlauncher_simple_uri_get_host (RoxenlauncherSimpleURI* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_host;
	return result;
}


void roxenlauncher_simple_uri_set_host (RoxenlauncherSimpleURI* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_host = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_host), _tmp0_);
	g_object_notify ((GObject *) self, "host");
}


const char* roxenlauncher_simple_uri_get_username (RoxenlauncherSimpleURI* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_username;
	return result;
}


void roxenlauncher_simple_uri_set_username (RoxenlauncherSimpleURI* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_username = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_username), _tmp0_);
	g_object_notify ((GObject *) self, "username");
}


const char* roxenlauncher_simple_uri_get_password (RoxenlauncherSimpleURI* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_password;
	return result;
}


void roxenlauncher_simple_uri_set_password (RoxenlauncherSimpleURI* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_password = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_password), _tmp0_);
	g_object_notify ((GObject *) self, "password");
}


gint roxenlauncher_simple_uri_get_port (RoxenlauncherSimpleURI* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_port;
	return result;
}


void roxenlauncher_simple_uri_set_port (RoxenlauncherSimpleURI* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_port = value;
	g_object_notify ((GObject *) self, "port");
}


const char* roxenlauncher_simple_uri_get_path (RoxenlauncherSimpleURI* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_path;
	return result;
}


void roxenlauncher_simple_uri_set_path (RoxenlauncherSimpleURI* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_path = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_path), _tmp0_);
	g_object_notify ((GObject *) self, "path");
}


const char* roxenlauncher_simple_uri_get_query (RoxenlauncherSimpleURI* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_query;
	return result;
}


void roxenlauncher_simple_uri_set_query (RoxenlauncherSimpleURI* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_query = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_query), _tmp0_);
	g_object_notify ((GObject *) self, "query");
}


const char* roxenlauncher_simple_uri_get_fragment (RoxenlauncherSimpleURI* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_fragment;
	return result;
}


void roxenlauncher_simple_uri_set_fragment (RoxenlauncherSimpleURI* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_fragment = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_fragment), _tmp0_);
	g_object_notify ((GObject *) self, "fragment");
}


static void roxenlauncher_simple_uri_class_init (RoxenlauncherSimpleURIClass * klass) {
	roxenlauncher_simple_uri_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RoxenlauncherSimpleURIPrivate));
	G_OBJECT_CLASS (klass)->get_property = roxenlauncher_simple_uri_get_property;
	G_OBJECT_CLASS (klass)->set_property = roxenlauncher_simple_uri_set_property;
	G_OBJECT_CLASS (klass)->finalize = roxenlauncher_simple_uri_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_SIMPLE_URI_SCHEME, g_param_spec_string ("scheme", "scheme", "scheme", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_SIMPLE_URI_HOST, g_param_spec_string ("host", "host", "host", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_SIMPLE_URI_USERNAME, g_param_spec_string ("username", "username", "username", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_SIMPLE_URI_PASSWORD, g_param_spec_string ("password", "password", "password", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_SIMPLE_URI_PORT, g_param_spec_int ("port", "port", "port", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_SIMPLE_URI_PATH, g_param_spec_string ("path", "path", "path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_SIMPLE_URI_QUERY, g_param_spec_string ("query", "query", "query", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ROXENLAUNCHER_SIMPLE_URI_FRAGMENT, g_param_spec_string ("fragment", "fragment", "fragment", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void roxenlauncher_simple_uri_instance_init (RoxenlauncherSimpleURI * self) {
	self->priv = ROXENLAUNCHER_SIMPLE_URI_GET_PRIVATE (self);
}


static void roxenlauncher_simple_uri_finalize (GObject* obj) {
	RoxenlauncherSimpleURI * self;
	self = ROXENLAUNCHER_SIMPLE_URI (obj);
	_g_free0 (self->priv->_scheme);
	_g_free0 (self->priv->_host);
	_g_free0 (self->priv->_username);
	_g_free0 (self->priv->_password);
	_g_free0 (self->priv->_path);
	_g_free0 (self->priv->_query);
	_g_free0 (self->priv->_fragment);
	G_OBJECT_CLASS (roxenlauncher_simple_uri_parent_class)->finalize (obj);
}


GType roxenlauncher_simple_uri_get_type (void) {
	static GType roxenlauncher_simple_uri_type_id = 0;
	if (roxenlauncher_simple_uri_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (RoxenlauncherSimpleURIClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) roxenlauncher_simple_uri_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RoxenlauncherSimpleURI), 0, (GInstanceInitFunc) roxenlauncher_simple_uri_instance_init, NULL };
		roxenlauncher_simple_uri_type_id = g_type_register_static (G_TYPE_OBJECT, "RoxenlauncherSimpleURI", &g_define_type_info, 0);
	}
	return roxenlauncher_simple_uri_type_id;
}


static void roxenlauncher_simple_uri_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	RoxenlauncherSimpleURI * self;
	self = ROXENLAUNCHER_SIMPLE_URI (object);
	switch (property_id) {
		case ROXENLAUNCHER_SIMPLE_URI_SCHEME:
		g_value_set_string (value, roxenlauncher_simple_uri_get_scheme (self));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_HOST:
		g_value_set_string (value, roxenlauncher_simple_uri_get_host (self));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_USERNAME:
		g_value_set_string (value, roxenlauncher_simple_uri_get_username (self));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_PASSWORD:
		g_value_set_string (value, roxenlauncher_simple_uri_get_password (self));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_PORT:
		g_value_set_int (value, roxenlauncher_simple_uri_get_port (self));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_PATH:
		g_value_set_string (value, roxenlauncher_simple_uri_get_path (self));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_QUERY:
		g_value_set_string (value, roxenlauncher_simple_uri_get_query (self));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_FRAGMENT:
		g_value_set_string (value, roxenlauncher_simple_uri_get_fragment (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void roxenlauncher_simple_uri_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	RoxenlauncherSimpleURI * self;
	self = ROXENLAUNCHER_SIMPLE_URI (object);
	switch (property_id) {
		case ROXENLAUNCHER_SIMPLE_URI_SCHEME:
		roxenlauncher_simple_uri_set_scheme (self, g_value_get_string (value));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_HOST:
		roxenlauncher_simple_uri_set_host (self, g_value_get_string (value));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_USERNAME:
		roxenlauncher_simple_uri_set_username (self, g_value_get_string (value));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_PASSWORD:
		roxenlauncher_simple_uri_set_password (self, g_value_get_string (value));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_PORT:
		roxenlauncher_simple_uri_set_port (self, g_value_get_int (value));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_PATH:
		roxenlauncher_simple_uri_set_path (self, g_value_get_string (value));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_QUERY:
		roxenlauncher_simple_uri_set_query (self, g_value_get_string (value));
		break;
		case ROXENLAUNCHER_SIMPLE_URI_FRAGMENT:
		roxenlauncher_simple_uri_set_fragment (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


gboolean roxenlauncher_alert_confirm (GtkWindow* parent, const char* message) {
	gboolean result;
	GtkMessageDialog* md;
	GtkResponseType resp;
	g_return_val_if_fail (parent != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	md = g_object_ref_sink ((GtkMessageDialog*) gtk_message_dialog_new (parent, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, message, ""));
	resp = (GtkResponseType) gtk_dialog_run ((GtkDialog*) md);
	gtk_object_destroy ((GtkObject*) md);
	result = resp == GTK_RESPONSE_YES;
	_g_object_unref0 (md);
	return result;
}


RoxenlauncherAlert* roxenlauncher_alert_construct (GType object_type) {
	RoxenlauncherAlert* self;
	self = (RoxenlauncherAlert*) g_type_create_instance (object_type);
	return self;
}


RoxenlauncherAlert* roxenlauncher_alert_new (void) {
	return roxenlauncher_alert_construct (ROXENLAUNCHER_TYPE_ALERT);
}


static void roxenlauncher_value_alert_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void roxenlauncher_value_alert_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		roxenlauncher_alert_unref (value->data[0].v_pointer);
	}
}


static void roxenlauncher_value_alert_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = roxenlauncher_alert_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer roxenlauncher_value_alert_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* roxenlauncher_value_alert_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		RoxenlauncherAlert* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = roxenlauncher_alert_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* roxenlauncher_value_alert_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	RoxenlauncherAlert** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = roxenlauncher_alert_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* roxenlauncher_param_spec_alert (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	RoxenlauncherParamSpecAlert* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ROXENLAUNCHER_TYPE_ALERT), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer roxenlauncher_value_get_alert (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ROXENLAUNCHER_TYPE_ALERT), NULL);
	return value->data[0].v_pointer;
}


void roxenlauncher_value_set_alert (GValue* value, gpointer v_object) {
	RoxenlauncherAlert* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ROXENLAUNCHER_TYPE_ALERT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ROXENLAUNCHER_TYPE_ALERT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		roxenlauncher_alert_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		roxenlauncher_alert_unref (old);
	}
}


static void roxenlauncher_alert_class_init (RoxenlauncherAlertClass * klass) {
	roxenlauncher_alert_parent_class = g_type_class_peek_parent (klass);
	ROXENLAUNCHER_ALERT_CLASS (klass)->finalize = roxenlauncher_alert_finalize;
}


static void roxenlauncher_alert_instance_init (RoxenlauncherAlert * self) {
	self->ref_count = 1;
}


static void roxenlauncher_alert_finalize (RoxenlauncherAlert* obj) {
	RoxenlauncherAlert * self;
	self = ROXENLAUNCHER_ALERT (obj);
}


GType roxenlauncher_alert_get_type (void) {
	static GType roxenlauncher_alert_type_id = 0;
	if (roxenlauncher_alert_type_id == 0) {
		static const GTypeValueTable g_define_type_value_table = { roxenlauncher_value_alert_init, roxenlauncher_value_alert_free_value, roxenlauncher_value_alert_copy_value, roxenlauncher_value_alert_peek_pointer, "p", roxenlauncher_value_alert_collect_value, "p", roxenlauncher_value_alert_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (RoxenlauncherAlertClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) roxenlauncher_alert_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RoxenlauncherAlert), 0, (GInstanceInitFunc) roxenlauncher_alert_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		roxenlauncher_alert_type_id = g_type_register_fundamental (g_type_fundamental_next (), "RoxenlauncherAlert", &g_define_type_info, &g_define_type_fundamental_info, 0);
	}
	return roxenlauncher_alert_type_id;
}


gpointer roxenlauncher_alert_ref (gpointer instance) {
	RoxenlauncherAlert* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void roxenlauncher_alert_unref (gpointer instance) {
	RoxenlauncherAlert* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ROXENLAUNCHER_ALERT_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




